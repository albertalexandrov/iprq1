# Безопасность в Django: что переносится на конфигурацию сервера

Ниже перечислены настройки сервера, влияющие на безопасность:

## ALLOWED_HOSTS

Список строк, представляющих имена хостов/доменов, которые может обслуживать данный Django-сайт.
Если заголовок Host (или `X-Forwarded-Host`, если включен `USE_X_FORWARDED_HOST`) не совпадает ни с одним значением 
в этом списке, метод `django.http.HttpRequest.get_host()` вызовет ошибку SuspiciousOperation.

## CSRF_COOKIE_SECURE

Следует ли использовать защищенный файл `cookie` для CSRF-файла cookie. Если для этого параметра установлено 
значение `True`, файл `cookie` будет помечен как “безопасный”, что означает, что браузеры могут гарантировать, 
что файл `cookie` отправляется только по HTTPS-соединению.

## CSRF_TRUSTED_ORIGINS

Список хостов, которые являются надежными источниками для небезопасных запросов (например, POST). Для безопасного 
небезопасного запроса защита `CSRF` Django требует, чтобы запрос имел заголовок `Referer`, который соответствует 
источнику, присутствующему в заголовке `Host`.

## EMAIL_USE_TLS

Следует ли использовать `TLS` соединение при общении с `SMTP`-сервером. Это используется для явных подключений `TLS`, 
как правило, на порту 587. 

## EMAIL_USE_SSL

Следует ли использовать неявное `TLS` соединение при общении с SMTP-сервером. В большинстве документации 
по электронной почте этот тип `TLS`-соединения упоминается как `SSL`. Обычно он используется на порту 465.

## EMAIL_SSL_CERTFILE

Если значение `EMAIL_USE_SSL` или `EMAIL_USE_TLS` равно `True`, можно дополнительно указать путь к файлу 
цепочки сертификатов в формате `PEM`, который будет использоваться для `SSL`-соединения.

## EMAIL_SSL_KEYFILE

Если значение `EMAIL_USE_SSL` или `EMAIL_USE_TLS` равно `True`, можно дополнительно указать путь к файлу 
закрытого ключа в формате `PEM`, который будет использоваться для `SSL`-соединения.

## LANGUAGE_COOKIE_SECURE

Следует ли использовать защищенный файл `cookie` для языкового файла `cookie`. Если для этого параметра 
установлено значение `True`, файл cookie будет помечен как “безопасный”, что означает, что браузеры могут 
гарантировать, что файл cookie отправляется только по `HTTPS`-соединению

## SECURE_BROWSER_XSS_FILTER

Если значение `True`, `SecurityMiddleware` устанавливает заголовок `X-XSS-Protection: 1; mode=block` 
для всех ответов, у которых его еще нет.

## SECURE_CONTENT_TYPE_NOSNIFF

Если значение `True`, `SecurityMiddleware` устанавливает заголовок `X-Content-Type-Options: nosniff` 
для всех ответов, у которых его еще нет.

## SECURE_CROSS_ORIGIN_OPENER_POLICY

Если не задано значение `None`, `SecurityMiddleware` устанавливает заголовок `Cross-Origin Opener Policy` 
для всех ответов, у которых его еще нет, на указанное значение.

## SECURE_HSTS_INCLUDE_SUBDOMAINS

Если значение `True`, `SecurityMiddleware` добавляет директиву `includeSubDomains` к заголовку 
`HTTP Strict Transport Security`. Это не имеет никакого эффекта, если для `SECURE_HSTS_SECONDS` 
не установлено ненулевое значение.

## SECURE_HSTS_PRELOAD

Если значение `True`, `SecurityMiddleware` добавляет директиву предварительной загрузки в заголовок `HTTP Strict Transport Security`. 
Это не имеет никакого эффекта, если для `SECURE_HSTS_SECONDS` не установлено ненулевое значение.

## SECURE_HSTS_SECONDS и SECURE_HSTS_INCLUDE_SUBDOMAINS

Заголовок `HTTP Strict Transport Security` (HSTS) информирует браузер о том, что все последующие запросы 
должны всегда использовать HTTPS. Совместно с перенаправлением HTTP запросов на HTTPS, эта опция позволяет 
обеспечить использование HTTPS в каждом запросе. HSTS может так же быть настроен опциями `SECURE_HSTS_SECONDS` 
и `SECURE_HSTS_INCLUDE_SUBDOMAINS` или на веб-сервере.

## SECURE_PROXY_SSL_HEADER

Кортеж, представляющий комбинацию заголовка/значения HTTP, которая означает, что запрос безопасен. 
Это контролирует поведение метода `is_secure()` объекта запроса.

Задает кортеж с двумя элементами – именем заголовка, который нужно искать, и требуемым значением. Например:

```python
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
```

Заголовок `X-Forwarded-Proto` (XFP) - это де-факто стандартный заголовок для идентификации протокола 
(HTTP или HTTPS), который клиент использовал для подключения к вашему прокси-серверу или балансировщику нагрузки. 
Журналы доступа к серверу содержат протокол, используемый между сервером и средством балансировки нагрузки, 
но не протокол, используемый между клиентом и средством балансировки нагрузки. Чтобы определить протокол, 
используемый между клиентом и балансировщиком нагрузки, можно использовать заголовок запроса `X-Forwarded-Proto`.

## SECURE_REDIRECT_EXEMPT

Если URL-адрес соответствует регулярному выражению в этом списке, запрос не будет перенаправлен на HTTPS. 
`SecurityMiddleware` удаляет начальные косые черты из путей URL, поэтому шаблоны не должны их включать.

## SECURE_REFERRER_POLICY

Если настроено, `SecurityMiddleware` устанавливает заголовок политики реферера для всех ответов, 
в которых он еще не указан, в указанное значение.

## SECURE_SSL_HOST

Если строка (например `secure.example.com`), все перенаправления `SSL` будут направлены на этот хост, 
а не на первоначально запрошенный хост (например, `www.example.com`).

## SECURE_SSL_REDIRECT

Если значение `True`, программное обеспечение `SecurityMiddleware` перенаправляет все запросы, отличные от HTTPS, 
на HTTPS (за исключением тех URL-адресов, которые соответствуют регулярному выражению, указанному 
в `SECURE_REDIRECT_EXEMPT`).

## SESSION_COOKIE_SECURE

Следует ли использовать защищенный файл `cookie` для сессионного файла `cookie`. Если для этого параметра установлено 
значение `True`, файл `cookie` будет помечен как “безопасный”, что означает, что браузеры могут гарантировать, 
что файл cookie отправляется только по `HTTPS`-соединению.